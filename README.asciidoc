= How to Build an NDP Driver

This guide will show you how to build a NDP client driver for Neo4j from scratch.
The example code here is written in Python but the same principles should apply for any language.
The only requirements for a driver project are raw socket capabilities so most languages should need no external library support.

NOTE: All values are sent and received in big-endian order unless otherwise noted.


== 1. Download and install the server

Alpha releases of Neo4j 3.0 can be found at http://alpha.neotechnology.com.s3-website-eu-west-1.amazonaws.com/.
These contain a version of NDP that listens by default on port 7687.


== 2. Perform a handshake

The handshake is used to determine which version of NDP should be used for that session.
This takes the form of an exchange of protocol version numbers, each represented as a 32-bit unsigned integer.
Firstly, the client sends exactly four possible version numbers in order of preference, using zeroes to pad if necessary.
In return, the server responds with its selection.
If no agreement can be made, the server responds with zero and closes the connection.

In the example below, the client offers protocol version 1 only:

----
Client: 00:00:00:01 00:00:00:00 00:00:00:00 00:00:00:00
----

The server then responds agreeably with version 1 as its selection:

----
Server: 00:00:00:01
----

The following code demonstrates how this exchange can be carried out:

[source,python]
----
def connect(host, port):
    """ Connect and perform a handshake in order to return a valid
    Connection object if a protocol version can be agreed.
    """

    # Establish a connection to the host and port specified
    log.info("Creating connection to %s on port %d" % (host, port))
    s = socket.create_connection((host, port))
    
    # Send details of the protocol versions supported
    supported_versions = [1, 0, 0, 0]
    log.info("Supported protocol versions are: %r" % supported_versions)
    data = b"".join(struct.pack(">I", version) for version in supported_versions)
    log.debug("Sending handshake data: %r" % data)
    s.sendall(data)
    
    # Handle the handshake response
    data = s.recv(4)
    log.debug("Received handshake data: %r" % data)
    agreed_version, = struct.unpack(">I", data)
    if agreed_version == 0:
        log.warning("Closing connection as no protocol version could be agreed")
        s.shutdown(socket.SHUT_RDWR)
        s.close()
    else:
        log.info("Protocol version %d agreed" % agreed_version)
        return Connection(s)
----


== 3. Send a request

=== 3.1. Prepare messages

[source,python]
----
log.info("Running statement %r with parameters %r" % (statement, parameters))
self._send((RUN, (statement, parameters)),
           (PULL_ALL, ()))
----

=== 3.2. Pack messages into bytes

[source,python]
----
def _send(self, *messages):
    """ Send one or more messages to the server.
    """
    raw = ChunkedIO()
    packer = Packer(raw)
    
    for message in messages:
        packer.pack(message)
        raw.flush(zero_chunk=True)

    data = raw.getvalue()
    log.debug("Sending request data: %r" % data)
    self.socket.sendall(data)
    
    raw.close()
----

=== 3.3. Split into chunks and send


== 4. Receive the responses

=== 4.1. Receive and collect chunks

=== 4.2. Unpack messages from bytes

=== 4.3. Interpret results

